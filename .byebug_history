exit
compute_position([-1, 2], [2, 1])
current_node.value
coords
current_node
legal_moves
step
potential_move
step
current_node
coords
legal_moves
step
within_range && !visited
visited
step
within_range
step
potential_move
step
is_legal_move?([0, 0])
compute_position(coords, current_node.value)
coords
step
current_node
step
current_node
step
queue.length
queue
next
queue
next
queue
next
queue
exit
restart
queue
queue.length
next
exit
restart
help
legal_moves
next
step
current_node
step
queue.length
queue
next
queue[2]
queue[1]
queue[0].parent
queue[0]
queue
next
queue
next
queue
exit
current_node
new_child
step
parent_node.children.include?(self)
step
parent_node.nil?
self
step
self
step
parent_node
step
new_child
step
child_pos
step
new_children
next
legal_moves
next
legal_moves
next
coords
legal_moves
next
is_legal_move?(coords)
coords
next
within_range
step
next
is_legal_move?(potential_move)
potential_move
step
legal_moves
step
is_legal_move?(compute_position(coords, current_node.value))
step
within_range && !visited
step
@visited_positions
step
(0..7).include?(pos)
pos
step
pos
potential_move
step
legal_moves
exit
xit
children
exit
children.length
children,length
children
exit
children.length
children
queue.each do |el| puts el.value end
queue.each
queue
next
queue
next
child.value
current_node.value
step
current_node.value
next
current_node.value
target_value
next
exit
current_node
next
current_node
next
exit
step
child
next
exit
final_node
step
next
child
step
next
queue.first.children
queue.first
queue
step
exit
next
help
